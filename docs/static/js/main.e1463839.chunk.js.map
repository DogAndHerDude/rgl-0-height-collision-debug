{"version":3,"sources":["NoHide/Enums.ts","NoHide/EditorView.tsx","NoHide/FinalView.tsx","utils.ts","NoHide/index.tsx","serviceWorker.ts","index.tsx"],"names":["LayoutUpdateSource","INITIAL_STATE","layout","i","w","h","x","y","minH","EditorView","state","toggleSingleElement","evt","index","currentTarget","dataset","setState","map","entry","nextEntry","hidden","isDraggable","isResizable","onLayoutChange","nextLayout","commitLayout","props","setLayout","maxH","Editor","className","onClick","this","mapButtons","width","margin","draggableCancel","compactType","cols","rowHeight","mapItems","key","data-index","React","PureComponent","View","toggleElement","changeInterceptor","verticalCompact","sort","a","b","Number","isHidden","element","intersectsXAxis","x0","x1","x2","x3","findBottomSiblings","elements","sorted","firstFoundSibling","siblings","filter","arr","intersects","length","App","hiddenElements","layoutYSiblingMap","source","buildLayoutYSiblingMap","console","log","buildHiddenElementState","find","hideElement","showElement","maxW","static","hiddenElement","normalizePositions","elementIndex","mapSiblingPositions","ii","sibling","deepSiblings","mappedDeepSiblings","mappedSibling","includes","findIndex","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e1463839.chunk.js","sourcesContent":["\n\n\nexport enum LayoutUpdateSource {\n  Editor = 0,\n  View = 1,\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  setLayout(layout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\nexport interface IState {\n  layout: Array<Layout>;\n}\n\n\nconst INITIAL_STATE: IState = {\n  layout: [\n    { i: '0', w: 2, h: 50, x: 0, y: 0, minH: 0 },\n    { i: '1', w: 2, h: 50, x: 2, y: 0, minH: 0 },\n    { i: '2', w: 4, h: 50, x: 0, y: 50, minH: 0 },\n    { i: '3', w: 2, h: 50, x: 0, y: 100, minH: 0 },\n    { i: '4', w: 2, h: 50, x: 2, y: 100, minH: 0 },\n    { i: '5', w: 2, h: 50, x: 0, y: 150, minH: 0 },\n    { i: '6', w: 2, h: 50, x: 2, y: 150, minH: 0 },\n    { i: '7', w: 2, h: 50, x: 0, y: 200, minH: 0 },\n    { i: '8', w: 2, h: 50, x: 2, y: 200, minH: 0 },\n    { i: '9', w: 2, h: 50, x: 0, y: 250, minH: 0 },\n    { i: '10', w: 2, h: 50, x: 2, y: 250, minH: 0 },\n    { i: '11', w: 2, h: 50, x: 0, y: 300, minH: 0 },\n    { i: '12', w: 2, h: 50, x: 2, y: 300, minH: 0 },\n    { i: '13', w: 2, h: 50, x: 0, y: 350, minH: 0 },\n    { i: '14', w: 2, h: 50, x: 2, y: 350, minH: 0 },\n    { i: '15', w: 2, h: 50, x: 0, y: 400, minH: 0 },\n    { i: '16', w: 2, h: 50, x: 2, y: 400, minH: 0 },\n    { i: '17', w: 2, h: 50, x: 0, y: 450, minH: 0 },\n    { i: '18', w: 2, h: 50, x: 2, y: 450, minH: 0 },\n    { i: '19', w: 2, h: 50, x: 0, y: 500, minH: 0 },\n    { i: '20', w: 2, h: 50, x: 2, y: 500, minH: 0 },\n  ],\n};\n\n\nexport default class EditorView extends React.PureComponent<IProps, IState> {\n\n  public state: IState = { ...INITIAL_STATE };\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"editor\">\n        <h1>Editor</h1>\n\n        <div className=\"main-action\">\n          <button className=\"save\" onClick={this.commitLayout}>Save Layout</button>\n        </div>\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={true}\n          isResizable={true}\n          compactType=\"vertical\"\n          layout={this.state.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.onLayoutChange}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <button key={entry.i} data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <div key={entry.i} className={`item ${entry.hidden ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n\n    return this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              const nextEntry = {\n                ...entry,\n                hidden: !entry.hidden,\n              };\n              if (entry.isDraggable) {\n                delete nextEntry.isDraggable;\n                delete nextEntry.isResizable;\n              } else {\n                nextEntry.isDraggable = true;\n                nextEntry.isResizable = true;\n              }\n              return nextEntry;\n            default:\n              return entry;\n          }\n        })\n      };\n    });\n  }\n\n  private onLayoutChange = (nextLayout: Array<Layout>): void => {\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: nextLayout,\n      };\n    });\n  }\n\n  private commitLayout = (): void => {\n    this.props.setLayout(this.state.layout.map(entry => {\n      switch (true) {\n        case entry.maxH !== void 0:\n          return {\n            ...entry,\n            h: 0,\n          };\n        default:\n          return entry;\n      }\n    }), LayoutUpdateSource.Editor);\n  }\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\n\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  layout: Array<Layout>;\n  toggleElement(index: string): void;\n  onLayoutChange(nextLayout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\n\nexport default class View extends React.PureComponent<IProps, {}> {\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"view\">\n        <h1>View</h1>\n\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={false}\n          isResizable={false}\n          verticalCompact={true}\n          compactType=\"vertical\"\n          layout={this.props.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.changeInterceptor}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.props.layout.sort((a, b) => Number(a.i) > Number(b.i) ? 1 : -1).map(entry => (\n      <button key={entry.i} data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.props.layout.map(entry => (\n      <div key={entry.i} className={`item ${this.isHidden(entry) ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private isHidden(element: Layout): boolean {\n    return element.maxH !== void 0 && element.h === 0;\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n    \n    this.props.toggleElement(index);\n  }\n\n  private changeInterceptor = (nextLayout: Array<Layout>): void => {\n    this.props.onLayoutChange(nextLayout, LayoutUpdateSource.View);\n  }\n}\n","\nimport { Layout } from 'react-grid-layout';\nimport { IHiddenElement, IBottomSiblings } from './App';\n\n\n\n\n\nexport function findUpperSibling(element: Layout, elements: Array<Layout>): Layout | undefined {\n  return elements\n    .sort((a, b) => a >= b ? -1 : 1)\n    .find((entry) => entry.y + entry.h === element.y);\n}\n\n\nexport function intersectsXAxis(x0: number, x1: number, x2: number, x3: number): boolean {\n  // Old collision check\n  // (x3 >= x0 && x3 <= x1) ||\n  // (x2 >= x0 && x2 <= x1) ||\n  // (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n  // (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n  return (x2 >= x0 && x2 < x1) || (x3 > x0 && x3 <= x1);\n}\n\n\nexport function findBottomSiblings(element: Layout, elements: Array<Layout>): Array<IBottomSiblings> {\n  const x0 = element.x;\n  const x1 = element.x + element.w;\n  const sorted = [...elements];\n\n  sorted.sort((a, b) => {\n    switch (true) {\n      case a.y > b.y:\n        return 1;\n      case a.y < b.y:\n        return -1;\n      default:\n        return 0;\n    }\n  });\n\n  const siblings = sorted.filter((entry, index, arr) => {\n    const x2 = entry.x;\n    const x3 = entry.x + entry.w;\n    const h = element.h === 0 && element.maxH !== void 0 ? element.maxH : element.h;\n    const intersects = element.i !== entry.i && element.y + h === entry.y && intersectsXAxis(x0, x1, x2, x3);\n\n    // Backwards lookup to see if the element is above it but not touching\n    // Meaning there's an empty space between the elements but potentially they could touch\n    if (!intersects) {\n      for (let i = index - 1; i > 0; i--) {\n        // We reached the current element that we are checking against\n        // Meaning we have an empty space between the reference element and the current element\n        // We consider as if they were touching. This accounts for any X-axis siblings making the elements ignore each because of an empty space.\n        // Long distance relationship, basically.\n        if (arr[i].i === element.i && intersectsXAxis(x0, x1, x2, x3)) {\n          return true;\n        }\n\n        // It is touching another element, so we ignore it.\n        if (arr[i].y + arr[i].h === entry.y && intersectsXAxis(x2, x3, arr[i].x, arr[i].x + arr[i].w)) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    return intersects;\n  });\n\n  /**\n   * NOTE:\n   * \n   * The above code is partially correct.\n   * What needs to be done is that I need to find all next potential siblings.\n   * But not the ones after the found siblings.\n   */\n\n  if (!siblings.length) {\n    let firstFoundSibling: Layout;\n\n    return sorted.filter(entry => {\n      const x2 = entry.x;\n      const x3 = entry.x + entry.w;\n\n      if (!firstFoundSibling) {\n        const intersects = entry.i !== element.i && entry.y >= element.y + element.h && intersectsXAxis(x0, x1, x2, x3);\n\n        if (intersects) {\n          firstFoundSibling = entry;\n        }\n\n        return intersects;\n      }\n\n      return entry.i !== element.i && entry.y === firstFoundSibling.y && intersectsXAxis(x0, x1, x2, x3);\n    });\n  }\n\n  return siblings.map(entry => ({\n    i: entry.i,\n    x: entry.x,\n    y: entry.y,\n  }));\n}\n\n\nexport function elementExists(index: string, elements: Array<Layout>): boolean {\n  return elements.findIndex(entry => entry.i === index) !== -1;\n}\n\n\nexport function hiddenElementExists(index: string, hiddenElements: Array<IHiddenElement>): boolean {\n  return hiddenElements.findIndex(entry => entry.element.i === index) !== -1;\n}\n\n\nexport function findXAxisCollisions(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const x2 = element.x;\n  const x3 = element.x + element.w;\n\n  return elements.filter(entry => {\n    const x0 = entry.x;\n    const x1 = entry.x + entry.w;\n\n    return (\n      (\n        (element.y >= entry.y && element.y + element.h >= entry.y) ||\n        (element.y <= entry.y + entry.h && element.y <= entry.y )\n      ) &&\n      (\n        (x3 >= x0 && x3 <= x1) ||\n        (x2 >= x0 && x2 <= x1) ||\n        (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n        (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n      )\n    );\n  });\n}\n\n\n// export function findCollisions(element: string, elements: Array<Layout>): Array<Layout> {\n//   return elements\n//     .sort((a, b) => a >= b ? -1 : 1)\n//     .filter(entry => (\n\n//     ));\n// }\n\n\nexport function findNearestSiblingToAppendAfter(siblingIndex: string, elements: Array<Layout>, hiddenElements: Array<IHiddenElement>): Layout | undefined {\n  if (hiddenElementExists(siblingIndex, hiddenElements)) {\n    const hiddenElement = hiddenElements.find(element => element.element.i === siblingIndex);\n    // If no element was found, it should check whether the position where the old hidden element used to be had\n    // any siblings on the X axis and check whether this element could potentially collide with those elements.\n    // If there are any collisions, find the first collision that has the heighest Y + H along the Y axis and return it as the append index\n\n    if (hiddenElement && !hiddenElement.upperSibling) {\n      // Should sort by by highest y + h in a descending manner\n      // TODO: Check whether the X axis sibling actually collides, just filter those that do not collide out\n      const xAxisSiblings = findXAxisCollisions(hiddenElement.element, elements)\n        .sort((a, b) => {\n          return a.y + a.h >= b.y + b.h ? -1 : 1;\n        });\n\n      if (xAxisSiblings.length === 0) {\n        return void 0;\n      }\n      \n      return xAxisSiblings[xAxisSiblings.length - 1];\n    }\n\n    if (!hiddenElement) {\n      return void 0;\n    }\n\n    return findNearestSiblingToAppendAfter(hiddenElement.upperSibling as string, elements, hiddenElements);\n  }\n\n  const element = elements.find(entry => entry.i === siblingIndex);\n\n  if (!element) {\n    return void 0;\n  }\n\n  return element;\n}\n\nexport function pushDownElements(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const collisions = findXAxisCollisions(element, elements);\n  \n  if (collisions.length === 0) {\n    return elements;\n  }\n\n  const nextLayout = elements.map(entry => {\n    if (entry.i === element.i) {\n      return entry;\n    }\n\n    const colliding = collisions.find(potentialCollision => potentialCollision.i === entry.i);\n\n    switch (true) {\n      case colliding !== void 0 && colliding.i === entry.i:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n\n  return nextLayout;\n  // return pushDownElements(collisions[])\n}\n\n\nexport function addElementAtPosition(pos: number, element: Layout, elements: Array<Layout>): Array<Layout> {\n  const nextLayout = [{\n    ...element,\n    y: pos,\n  }, ...elements];\n\n  return pushDownElements(element, nextLayout);\n}\n\n\nexport function adjustBottomSiblings(element: Layout, siblings: Array<IBottomSiblings>, elements: Array<Layout>): Array<Layout> {\n  return elements.map(entry => {\n    if (element.i === entry.i) {\n      return entry;\n    }\n\n    const isSibling = siblings.find(sibling => sibling.i === entry.i) !== void 0;\n\n    switch (isSibling) {\n      case true:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n}","\nimport React from 'react';\nimport { Layout } from 'react-grid-layout';\n\nimport Editor from './EditorView';\nimport View from './FinalView';\nimport { findBottomSiblings } from '../utils';\n\nimport './Style.css';\nimport 'react-grid-layout/css/styles.css';\nimport { LayoutUpdateSource } from './Enums';\n\n\n\n\ninterface IState {\n  layout: Array<Layout>;\n  hiddenElements: Array<string>;\n}\n\n\nexport default class App extends React.PureComponent<{}, IState> {\n\n  public state: IState = {\n    layout: [],\n    hiddenElements: [],\n  }\n\n  private layoutYSiblingMap: Record<string, Array<string>> = {};\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"base\">\n        <Editor setLayout={this.setLayout} />\n        <View layout={this.state.layout} toggleElement={this.toggleElement} onLayoutChange={this.setLayout} />\n      </div>\n    );\n  }\n\n  private setLayout = (layout: Array<Layout>, source: LayoutUpdateSource): void => {\n    if (source === LayoutUpdateSource.Editor) {\n      this.buildLayoutYSiblingMap(layout);\n      console.log('Built map:', this.layoutYSiblingMap);\n    }\n\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout,\n        hiddenElements: source === LayoutUpdateSource.Editor ? this.buildHiddenElementState(layout) : state.hiddenElements,\n      };\n    });\n  }\n\n  private buildHiddenElementState(layout: Array<Layout>): Array<string> {\n    return layout\n      .filter(entry => entry.maxH !== void 0)\n      .map(entry => entry.i);\n  }\n\n  private buildLayoutYSiblingMap(layout: Array<Layout>): void {\n    for (const element of layout) {\n      this.layoutYSiblingMap[element.i] = findBottomSiblings(element, layout).map(entry => entry.i);\n    }\n  }\n\n  private toggleElement = (index: string): void => {\n    const element = this.state.layout.find(entry => entry.i === index);\n\n    if (!element) {\n      return;\n    }\n\n    switch (true) {\n      case element.i === index && element.maxH === void 0 && element.h !== 0:\n        return this.hideElement(index);\n      case element.i === index && element.maxH !== void 0 && element.h === 0:\n        return this.showElement(index);\n      default:\n        return;\n    }\n  }\n\n  private hideElement(index: string): void {\n    this.setState((state: IState) => {\n      const element = state.layout.find(entry => entry.i === index);\n\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                w: 0,\n                h: 0,\n                maxH: entry.h,\n                maxW: entry.w,\n                static: true,\n              };\n            default:\n              return entry;\n          }\n        }),\n        hiddenElements: !element ? state.hiddenElements : [...state.hiddenElements, element.i],\n      };\n    });\n  }\n\n  private showElement(index: string): void {\n    const hiddenElement = this.state.hiddenElements.find(entry => entry === index);\n\n    if (!hiddenElement) {\n      return;\n    }\n\n    this.setState((state: IState) => {\n      const nextLayout = state.layout\n        .map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                w: entry.maxW as number,\n                h: entry.maxH as number,\n                maxW: void 0,\n                maxH: void 0,\n                static: false,\n              };\n            default:\n              return entry;\n          }\n        });\n\n      return {\n        ...state,\n        layout: this.normalizePositions(index, nextLayout),\n        hiddenElements: state.hiddenElements.filter(entry => entry !== hiddenElement),\n      };\n    });\n  }\n\n  /**\n   * Normalizes positions so they would follow the correct order as on init.\n   * \n   * @param elementIndex Index of an element that got triggered to be shown\n   * @param layout       Layout upon which the action takes place\n   */\n  private normalizePositions(elementIndex: string, layout: Array<Layout>): Array<Layout> {\n    const element = layout.find(entry => entry.i === elementIndex);\n    const siblings = this.layoutYSiblingMap[elementIndex];\n\n    if (!element || !siblings || !siblings.length) {\n      return layout;\n    }\n\n    return this.mapSiblingPositions(element, siblings, layout);\n  }\n\n  /**\n   * Sifts through siblings recursively to update the layout with correct layout positions.\n   * \n   * @param element  Element that serves as a reference point which other elements should follow\n   * @param siblings Siblings of the element\n   * @param layout   Layout upon which the action takes place\n   */\n  private mapSiblingPositions(element: Layout, siblings: Array<string>, layout: Array<Layout>): Array<Layout> {\n    let nextLayout = [...layout];\n\n    for (let i = 0, ii = nextLayout.length; i < ii; i++) {\n      // eslint-disable-next-line\n      const sibling = siblings.find(entry => entry === nextLayout[i].i);\n\n      if (!sibling) {\n        continue;\n      }\n\n      /**\n       * This case denotes that the sibling is hidden.\n       * In this case we pass the sibling's siblings recursively with the current element being as its\n       * reference point which the other siblings should follow.\n       */\n      if (nextLayout[i].hidden) {\n        // Sibling's siblings\n        const deepSiblings = this.layoutYSiblingMap[sibling];\n\n        if (!deepSiblings || !deepSiblings.length) {\n          continue;\n        }\n\n        const mappedDeepSiblings = this.mapSiblingPositions(element, deepSiblings, layout);\n\n        for (const mappedSibling of mappedDeepSiblings) {\n          // If it's not the adjust sibling we just move along\n          if (!deepSiblings.includes(mappedSibling.i)) {\n            continue;\n          }\n\n          const index = nextLayout.findIndex(entry => entry.i === mappedSibling.i);\n\n          // Saftey just in case, could be a bit over the top, but otherwise TypeScript will scream bloody murder at you\n          if (index === -1) {\n            continue;\n          }\n\n          // Assigned the newly mapped sibling to the current layout\n          nextLayout[index] = mappedSibling;\n        }\n      }\n\n      if (element.y + element.h > nextLayout[i].y) {\n        // Push the sibling down bellow the reference element\n        nextLayout[i] = {\n          ...nextLayout[i],\n          y: element.y + element.h,\n        };\n      }\n    }\n\n    // Now update sibling's siblings\n    for (const sibling of siblings) {\n      const element = nextLayout.find(entry => entry.i === sibling);\n      const deepSiblings = this.layoutYSiblingMap[sibling];\n\n      if (!element || !deepSiblings || !deepSiblings.length) {\n        continue;\n      }\n\n      nextLayout = this.mapSiblingPositions(element, deepSiblings, nextLayout);\n    }\n\n    return nextLayout;\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport NoHideApp from './NoHide';\nimport * as serviceWorker from './serviceWorker';\n\n// ReactDOM.render(<App />, document.getElementById('root'));\nReactDOM.render(<NoHideApp />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
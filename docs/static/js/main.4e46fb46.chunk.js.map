{"version":3,"sources":["NoHide/Enums.ts","NoHide/EditorView.tsx","NoHide/FinalView.tsx","utils.ts","NoHide/index.tsx","serviceWorker.ts","index.tsx"],"names":["LayoutUpdateSource","INITIAL_STATE","layout","i","w","h","x","y","minH","EditorView","state","toggleSingleElement","evt","index","currentTarget","dataset","setState","map","entry","maxH","onLayoutChange","nextLayout","commitLayout","props","setLayout","Editor","className","onClick","this","mapButtons","width","margin","draggableCancel","isDraggable","isResizable","compactType","cols","rowHeight","mapItems","data-index","key","isHidden","element","React","PureComponent","View","toggleElement","changeInterceptor","verticalCompact","findBottomSiblings","elements","sort","a","b","filter","App","hiddenElements","layoutYSiblingMap","source","buildLayoutYSiblingMap","find","hideElement","showElement","maxW","static","bottomSiblings","hiddenElement","normalizePositions","keys","Object","mapElementSiblingPositions","forceY","siblings","ii","length","includes","console","log","mappedLayout","nEntry","mappedElement","mappedEntry","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4e46fb46.chunk.js","sourcesContent":["\n\n\nexport enum LayoutUpdateSource {\n  Editor = 0,\n  View = 1,\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  setLayout(layout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\nexport interface IState {\n  layout: Array<Layout>;\n}\n\n\nconst INITIAL_STATE: IState = {\n  layout: [\n    { i: '0', w: 2, h: 50, x: 0, y: 0, minH: 0 },\n    { i: '1', w: 2, h: 50, x: 2, y: 0, minH: 0 },\n    { i: '2', w: 4, h: 50, x: 0, y: 50, minH: 0 },\n    { i: '3', w: 2, h: 50, x: 0, y: 100, minH: 0 },\n    { i: '4', w: 2, h: 50, x: 2, y: 100, minH: 0 },\n    { i: '5', w: 2, h: 50, x: 0, y: 150, minH: 0 },\n    { i: '6', w: 2, h: 50, x: 2, y: 150, minH: 0 },\n    { i: '7', w: 2, h: 50, x: 0, y: 200, minH: 0 },\n    { i: '8', w: 2, h: 50, x: 2, y: 200, minH: 0 },\n    { i: '9', w: 2, h: 50, x: 0, y: 250, minH: 0 },\n    { i: '10', w: 2, h: 50, x: 2, y: 250, minH: 0 },\n    { i: '11', w: 2, h: 50, x: 0, y: 300, minH: 0 },\n    { i: '12', w: 2, h: 50, x: 2, y: 300, minH: 0 },\n    { i: '13', w: 2, h: 50, x: 0, y: 350, minH: 0 },\n    { i: '14', w: 2, h: 50, x: 2, y: 350, minH: 0 },\n    { i: '15', w: 2, h: 50, x: 0, y: 400, minH: 0 },\n    { i: '16', w: 2, h: 50, x: 2, y: 400, minH: 0 },\n    { i: '17', w: 2, h: 50, x: 0, y: 450, minH: 0 },\n    { i: '18', w: 2, h: 50, x: 2, y: 450, minH: 0 },\n    { i: '19', w: 2, h: 50, x: 0, y: 500, minH: 0 },\n    { i: '20', w: 2, h: 50, x: 2, y: 500, minH: 0 },\n  ],\n};\n\n\nexport default class EditorView extends React.PureComponent<IProps, IState> {\n\n  public state: IState = { ...INITIAL_STATE };\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"editor\">\n        <h1>Editor</h1>\n\n        <div className=\"main-action\">\n          <button className=\"save\" onClick={this.commitLayout}>Save Layout</button>\n        </div>\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={true}\n          isResizable={true}\n          compactType=\"vertical\"\n          layout={this.state.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.onLayoutChange}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <button data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <div key={entry.i} className={`item ${this.isHidden(entry) ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private isHidden(element: Layout): boolean {\n    return element.maxH !== void 0;\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n\n    return this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                maxH: entry.maxH !== void 0 ? void 0 : entry.h,\n              };\n            default:\n              return entry;\n          }\n        })\n      };\n    });\n  }\n\n  private onLayoutChange = (nextLayout: Array<Layout>): void => {\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: nextLayout,\n      };\n    });\n  }\n\n  private commitLayout = (): void => {\n    this.props.setLayout(this.state.layout.map(entry => {\n      switch (true) {\n        case entry.maxH !== void 0:\n          return {\n            ...entry,\n            h: 0,\n          };\n        default:\n          return entry;\n      }\n    }), LayoutUpdateSource.Editor);\n  }\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\n\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  layout: Array<Layout>;\n  toggleElement(index: string): void;\n  onLayoutChange(nextLayout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\n\nexport default class View extends React.PureComponent<IProps, {}> {\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"view\">\n        <h1>View</h1>\n\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={false}\n          isResizable={false}\n          verticalCompact={true}\n          compactType=\"vertical\"\n          layout={this.props.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.changeInterceptor}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.props.layout.map(entry => (\n      <button data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.props.layout.map(entry => (\n      <div key={entry.i} className={`item ${this.isHidden(entry) ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private isHidden(element: Layout): boolean {\n    return element.maxH !== void 0 && element.h === 0;\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n    \n    this.props.toggleElement(index);\n  }\n\n  private changeInterceptor = (nextLayout: Array<Layout>): void => {\n    this.props.onLayoutChange(nextLayout, LayoutUpdateSource.View);\n  }\n}\n","\nimport { Layout } from 'react-grid-layout';\nimport { IHiddenElement, IBottomSiblings } from './App';\n\n\n\n\n\nexport function findUpperSibling(element: Layout, elements: Array<Layout>): Layout | undefined {\n  return elements\n    .sort((a, b) => a >= b ? -1 : 1)\n    .find((entry) => entry.y + entry.h === element.y);\n}\n\n\nexport function findBottomSiblings(element: Layout, elements: Array<Layout>): Array<IBottomSiblings> {\n  return elements\n    .sort((a, b) => a >= b ? -1 : 1)\n    .filter(entry => element.i !== entry.i && element.y + element.h === entry.y)\n    .map(entry => ({\n      i: entry.i,\n      x: entry.x,\n      y: entry.y,\n    }));\n}\n\n\nexport function elementExists(index: string, elements: Array<Layout>): boolean {\n  return elements.findIndex(entry => entry.i === index) !== -1;\n}\n\n\nexport function hiddenElementExists(index: string, hiddenElements: Array<IHiddenElement>): boolean {\n  return hiddenElements.findIndex(entry => entry.element.i === index) !== -1;\n}\n\n\nexport function findXAxisCollisions(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const x2 = element.x;\n  const x3 = element.x + element.w;\n\n  return elements.filter(entry => {\n    const x0 = entry.x;\n    const x1 = entry.x + entry.w;\n\n    return (\n      (\n        (element.y >= entry.y && element.y + element.h >= entry.y) ||\n        (element.y <= entry.y + entry.h && element.y <= entry.y )\n      ) &&\n      (\n        (x3 >= x0 && x3 <= x1) ||\n        (x2 >= x0 && x2 <= x1) ||\n        (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n        (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n      )\n    );\n  });\n}\n\n\n// export function findCollisions(element: string, elements: Array<Layout>): Array<Layout> {\n//   return elements\n//     .sort((a, b) => a >= b ? -1 : 1)\n//     .filter(entry => (\n\n//     ));\n// }\n\n\nexport function findNearestSiblingToAppendAfter(siblingIndex: string, elements: Array<Layout>, hiddenElements: Array<IHiddenElement>): Layout | undefined {\n  if (hiddenElementExists(siblingIndex, hiddenElements)) {\n    const hiddenElement = hiddenElements.find(element => element.element.i === siblingIndex);\n    // If no element was found, it should check whether the position where the old hidden element used to be had\n    // any siblings on the X axis and check whether this element could potentially collide with those elements.\n    // If there are any collisions, find the first collision that has the heighest Y + H along the Y axis and return it as the append index\n\n    if (hiddenElement && !hiddenElement.upperSibling) {\n      // Should sort by by highest y + h in a descending manner\n      // TODO: Check whether the X axis sibling actually collides, just filter those that do not collide out\n      const xAxisSiblings = findXAxisCollisions(hiddenElement.element, elements)\n        .sort((a, b) => {\n          return a.y + a.h >= b.y + b.h ? -1 : 1;\n        });\n\n      if (xAxisSiblings.length === 0) {\n        return void 0;\n      }\n      \n      return xAxisSiblings[xAxisSiblings.length - 1];\n    }\n\n    if (!hiddenElement) {\n      return void 0;\n    }\n\n    return findNearestSiblingToAppendAfter(hiddenElement.upperSibling as string, elements, hiddenElements);\n  }\n\n  const element = elements.find(entry => entry.i === siblingIndex);\n\n  if (!element) {\n    return void 0;\n  }\n\n  return element;\n}\n\nexport function pushDownElements(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const collisions = findXAxisCollisions(element, elements);\n  \n  if (collisions.length === 0) {\n    return elements;\n  }\n\n  const nextLayout = elements.map(entry => {\n    if (entry.i === element.i) {\n      return entry;\n    }\n\n    const colliding = collisions.find(potentialCollision => potentialCollision.i === entry.i);\n\n    switch (true) {\n      case colliding !== void 0 && colliding.i === entry.i:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n\n  return nextLayout;\n  // return pushDownElements(collisions[])\n}\n\n\nexport function addElementAtPosition(pos: number, element: Layout, elements: Array<Layout>): Array<Layout> {\n  const nextLayout = [{\n    ...element,\n    y: pos,\n  }, ...elements];\n\n  return pushDownElements(element, nextLayout);\n}\n\n\nexport function adjustBottomSiblings(element: Layout, siblings: Array<IBottomSiblings>, elements: Array<Layout>): Array<Layout> {\n  return elements.map(entry => {\n    if (element.i === entry.i) {\n      return entry;\n    }\n\n    const isSibling = siblings.find(sibling => sibling.i === entry.i) !== void 0;\n\n    switch (isSibling) {\n      case true:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n}","\nimport React from 'react';\nimport { Layout } from 'react-grid-layout';\n\nimport Editor from './EditorView';\nimport View from './FinalView';\nimport { findBottomSiblings } from '../utils';\n\nimport './Style.css';\nimport 'react-grid-layout/css/styles.css';\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IHiddenElement {\n  i: string;\n  bottomSiblings: Array<string>;\n}\n\n\ninterface IState {\n  layout: Array<Layout>;\n  hiddenElements: Array<IHiddenElement>;\n}\n\n\nexport default class App extends React.PureComponent<{}, IState> {\n\n  public state: IState = {\n    layout: [],\n    hiddenElements: [],\n  }\n\n  private layoutYSiblingMap: Record<string, Array<string>> = {};\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"base\">\n        <Editor setLayout={this.setLayout} />\n        <View layout={this.state.layout} toggleElement={this.toggleElement} onLayoutChange={this.setLayout} />\n      </div>\n    );\n  }\n\n  private setLayout = (layout: Array<Layout>, source: LayoutUpdateSource): void => {\n    if (source === LayoutUpdateSource.Editor) {\n      this.buildLayoutYSiblingMap(layout);\n    }\n\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout,\n      };\n    })\n  }\n\n  private buildLayoutYSiblingMap(layout: Array<Layout>): void {\n    for (const element of layout) {\n      this.layoutYSiblingMap[element.i] = findBottomSiblings(element, layout).map(entry => entry.i);\n    }\n  }\n\n  private toggleElement = (index: string): void => {\n    const element = this.state.layout.find(entry => entry.i === index);\n\n    if (!element) {\n      return;\n    }\n\n    switch (true) {\n      case element.i === index && element.maxH === void 0 && element.h !== 0:\n        return this.hideElement(index);\n      case element.i === index && element.maxH !== void 0 && element.h === 0:\n        return this.showElement(index);\n      default:\n        return;\n    }\n  }\n\n  private hideElement(index: string): void {\n    this.setState((state: IState) => {\n      const element = state.layout.find(entry => entry.i === index);\n\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                w: 0,\n                h: 0,\n                maxH: entry.h,\n                maxW: entry.w,\n                static: true,\n              };\n            default:\n              return entry;\n          }\n        }),\n        hiddenElements: !element ? state.hiddenElements : [...state.hiddenElements, {\n          i: element.i,\n          bottomSiblings: findBottomSiblings(element, state.layout).map(entry => entry.i),\n        }],\n      };\n    });\n  }\n\n  private showElement(index: string): void {\n    const hiddenElement = this.state.hiddenElements.find(entry => entry.i === index);\n\n    if (!hiddenElement) {\n      return;\n    }\n    /**\n     * Alternative solution to bellow code:\n     * \n     * Produce a map on init with bottom siblings for all elements.\n     * When visibility is being restored, make sure that old positions are being respected,\n     * i.e. it is exactly bellow the given component.\n     * However, this will include a lot of maps, which might impact the performance.\n     */\n    this.setState((state: IState) => {\n      const nextLayout = state.layout\n        .map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                w: entry.maxW as number,\n                h: entry.maxH as number,\n                maxW: void 0,\n                maxH: void 0,\n                static: false,\n              };\n            default:\n              return entry;\n          }\n        });\n\n      return {\n        ...state,\n        layout: this.normalizePositions(nextLayout),\n        hiddenElements: state.hiddenElements.filter(entry => entry.i !== hiddenElement.i),\n      };\n    });\n  }\n\n  private normalizePositions(layout: Array<Layout>): Array<Layout> {\n    const keys = Object.keys(this.layoutYSiblingMap);\n    let nextLayout = [...layout];\n\n    for (const key of keys) {\n      const element = nextLayout.find(entry => entry.i === key);\n\n      if (!element || element.static) {\n        continue;\n      }\n\n      nextLayout = this.mapElementSiblingPositions(element, nextLayout);\n      // if (!element || element.static) {\n      //   continue;\n      // }\n\n      // const siblings = this.layoutYSiblingMap[key];\n      //       nextLayout = nextLayout.map(entry => {\n      //         const isSibling = siblings.includes(entry.i);\n\n      //         // Hidden elements are static and will never move, so we don't do anything with it\n      //         if (entry.static || !isSibling) {\n      //           return entry;\n      //         }\n\n              // if (entry.y !== element.y + element.h) {\n              //   return {\n              //     ...entry,\n              //     y: element.y + element.h,\n              //   };\n              // }\n\n      //         return entry;\n      //       });\n    }\n\n    return nextLayout;\n  }\n\n  private mapElementSiblingPositions(element: Layout, layout: Array<Layout>, forceY?: number): Array<Layout> {\n    let nextLayout = [...layout];\n    const siblings = this.layoutYSiblingMap[element.i];\n\n    for (let i = 0, ii = nextLayout.length; i < ii; i++) {\n      const entry = nextLayout[i];\n      const isSibling = siblings.includes(entry.i);\n\n      if (!isSibling) {\n        continue;\n      }\n\n      // If the element is hidden we adjust its siblings instead to account for new positions\n      if (entry.static) {\n        console.log('Mapping hidden:', entry.i, 'Sibling of:', element.i, 'Forcing Y:', forceY);\n        const mappedLayout = this.mapElementSiblingPositions(entry, nextLayout, forceY !== void 0 ? forceY : element.y + element.h);\n\n        nextLayout = nextLayout.map(nEntry => {\n          const mappedElement = mappedLayout.find(mappedEntry => mappedEntry.i === nEntry.i);\n\n          if (!mappedElement) {\n            return nEntry;\n          }\n\n          return mappedElement;\n        });\n      }\n\n      if (forceY === void 0 && entry.y !== element.y + element.h) {\n        nextLayout[i] = {\n          ...entry,\n          y: element.y + element.h,\n        };\n      }\n\n      if (forceY !== void 0) {\n        nextLayout[i] = {\n          ...entry,\n          y: forceY,\n        };\n      }\n    }\n\n    return nextLayout;\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport NoHideApp from './NoHide';\nimport * as serviceWorker from './serviceWorker';\n\n// ReactDOM.render(<App />, document.getElementById('root'));\nReactDOM.render(<NoHideApp />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
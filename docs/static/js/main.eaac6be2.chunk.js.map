{"version":3,"sources":["NoHide/Enums.ts","NoHide/EditorView.tsx","NoHide/FinalView.tsx","utils.ts","NoHide/index.tsx","serviceWorker.ts","index.tsx"],"names":["LayoutUpdateSource","INITIAL_STATE","layout","i","w","h","x","y","minH","EditorView","state","toggleSingleElement","evt","index","currentTarget","dataset","setState","map","entry","maxW","maxH","onLayoutChange","nextLayout","commitLayout","props","setLayout","Editor","className","onClick","this","mapButtons","width","margin","draggableCancel","isDraggable","isResizable","compactType","cols","rowHeight","mapItems","key","data-index","isHidden","element","React","PureComponent","View","toggleElement","changeInterceptor","verticalCompact","sort","a","b","Number","findBottomSiblings","elements","x2","x3","sorted","siblings","filter","x0","x1","length","selfIndex","findIndex","App","hiddenElements","layoutYSiblingMap","source","buildLayoutYSiblingMap","buildHiddenElementState","find","hideElement","showElement","push","bottomSiblings","console","log","static","hiddenElement","normalizePositions","keys","Object","mapElementSiblingPositions","forceY","ii","includes","mappedLayout","nEntry","mappedElement","mappedEntry","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"0NAGYA,E,qHAAAA,O,mBAAAA,I,gBAAAA,M,KCaZ,IAAMC,EAAwB,CAC5BC,OAAQ,CACN,CAAEC,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,EAAGC,KAAM,GACzC,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,EAAGC,KAAM,GACzC,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,GAAIC,KAAM,GAC1C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,IAAKC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC3C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,GAC5C,CAAEL,EAAG,KAAMC,EAAG,EAAGC,EAAG,GAAIC,EAAG,EAAGC,EAAG,IAAKC,KAAM,KAK3BC,E,2MAEZC,M,eAAqBT,G,EAgDpBU,oBAAsB,SAACC,GAC7B,IAAMC,EAAQD,EAAIE,cAAcC,QAAQF,MAExC,GAAKA,EAIL,OAAO,EAAKG,UAAS,SAACN,GACpB,OAAO,eACFA,EADL,CAEER,OAAQQ,EAAMR,OAAOe,KAAI,SAAAC,GACvB,OAAQA,EAAMf,GACZ,KAAKU,EACH,OAAO,eACFK,EADL,CAEEC,UAAqB,IAAfD,EAAMC,UAAkB,EAASD,EAAMd,EAC7CgB,UAAqB,IAAfF,EAAME,UAAkB,EAASF,EAAMb,IAEjD,QACE,OAAOa,Y,EAOXG,eAAiB,SAACC,GACxB,EAAKN,UAAS,SAACN,GACb,OAAO,eACFA,EADL,CAEER,OAAQoB,Q,EAKNC,aAAe,WACrB,EAAKC,MAAMC,UAAU,EAAKf,MAAMR,OAAOe,KAAI,SAAAC,GACzC,QAAQ,GACN,UAAoB,IAAfA,EAAME,KACT,OAAO,eACFF,EADL,CAEEb,EAAG,IAEP,QACE,OAAOa,MAETlB,EAAmB0B,S,wEA3FvB,OACE,yBAAKC,UAAU,UACb,sCAEA,yBAAKA,UAAU,eACb,4BAAQA,UAAU,OAAOC,QAASC,KAAKN,cAAvC,gBAEDM,KAAKC,aAEN,kBAAC,IAAD,CACEC,MAAO,IACPC,OAAQ,CAAC,EAAG,GACZC,gBAAgB,iBAChBC,aAAa,EACbC,aAAa,EACbC,YAAY,WACZlC,OAAQ2B,KAAKnB,MAAMR,OACnBmC,KAAM,EACNC,UAAW,EACXjB,eAAgBQ,KAAKR,gBAEpBQ,KAAKU,e,mCAMgC,IAAD,OAC3C,OAAOV,KAAKnB,MAAMR,OAAOe,KAAI,SAAAC,GAAK,OAChC,4BAAQsB,IAAKtB,EAAMf,EAAGsC,aAAYvB,EAAMf,EAAGyB,QAAS,EAAKjB,qBAAzD,UAAsFO,EAAMf,Q,iCAIpD,IAAD,OACzC,OAAO0B,KAAKnB,MAAMR,OAAOe,KAAI,SAAAC,GAAK,OAChC,yBAAKsB,IAAKtB,EAAMf,EAAGwB,UAAS,eAAU,EAAKe,SAASxB,GAAS,SAAW,KACrEA,EAAMf,Q,+BAKIwC,GACf,YAAwB,IAAjBA,EAAQvB,S,GA/CqBwB,IAAMC,eC5BzBC,E,2MA8CXnC,oBAAsB,SAACC,GAC7B,IAAMC,EAAQD,EAAIE,cAAcC,QAAQF,MAEnCA,GAIL,EAAKW,MAAMuB,cAAclC,I,EAGnBmC,kBAAoB,SAAC1B,GAC3B,EAAKE,MAAMH,eAAeC,EAAYtB,EAAmB8C,O,wEAtDzD,OACE,yBAAKnB,UAAU,QACb,oCAECE,KAAKC,aAEN,kBAAC,IAAD,CACEC,MAAO,IACPC,OAAQ,CAAC,EAAG,GACZC,gBAAgB,iBAChBC,aAAa,EACbC,aAAa,EACbc,iBAAiB,EACjBb,YAAY,WACZlC,OAAQ2B,KAAKL,MAAMtB,OACnBmC,KAAM,EACNC,UAAW,EACXjB,eAAgBQ,KAAKmB,mBAEpBnB,KAAKU,e,mCAMgC,IAAD,OAC3C,OAAOV,KAAKL,MAAMtB,OAAOgD,MAAK,SAACC,EAAGC,GAAJ,OAAUC,OAAOF,EAAEhD,GAAKkD,OAAOD,EAAEjD,GAAK,GAAK,KAAGc,KAAI,SAAAC,GAAK,OACnF,4BAAQsB,IAAKtB,EAAMf,EAAGsC,aAAYvB,EAAMf,EAAGyB,QAAS,EAAKjB,qBAAzD,UAAsFO,EAAMf,Q,iCAIpD,IAAD,OACzC,OAAO0B,KAAKL,MAAMtB,OAAOe,KAAI,SAAAC,GAAK,OAChC,yBAAKsB,IAAKtB,EAAMf,EAAGwB,UAAS,eAAU,EAAKe,SAASxB,GAAS,SAAW,KACrEA,EAAMf,Q,+BAKIwC,GACf,YAAwB,IAAjBA,EAAQvB,MAAiC,IAAduB,EAAQtC,M,GA3CZuC,IAAMC,eCAjC,SAASS,EAAmBX,EAAiBY,GAClD,IAAMC,EAAKb,EAAQrC,EACbmD,EAAKd,EAAQrC,EAAIqC,EAAQvC,EAEzBsD,EAASH,EAASL,MAAK,SAACC,EAAGC,GAC/B,QAAQ,GACN,KAAKD,EAAIC,EACP,OAAQ,EACV,KAAKD,EAAIC,EACP,OAAO,EACT,QACE,OAAO,MAGPO,EAAWD,EAAOE,QAAO,SAAA1C,GAC7B,IAAM2C,EAAK3C,EAAMZ,EACXwD,EAAK5C,EAAMZ,EAAIY,EAAMd,EACrBC,EAAkB,IAAdsC,EAAQtC,QAA4B,IAAjBsC,EAAQvB,KAAkBuB,EAAQvB,KAAOuB,EAAQtC,EAC9E,OAAOsC,EAAQxC,IAAMe,EAAMf,GAAKwC,EAAQpC,EAAIF,IAAMa,EAAMX,IACrDkD,GAAMI,GAAMJ,GAAMK,GAClBN,GAAMK,GAAML,GAAMM,GAClBD,GAAML,GAAMK,GAAMJ,GAAMK,GAAMN,GAAMM,GAAML,GAC1CD,GAAMK,GAAML,GAAMM,GAAML,GAAMI,GAAMJ,GAAMK,MAK/C,IAAKH,EAASI,OAAQ,CACpB,IAAMC,EAAYN,EAAOO,WAAU,SAAA/C,GAAK,OAAIA,EAAMf,IAAMwC,EAAQxC,KAIhE,OAAOuD,EAAOE,QAAO,SAAC1C,EAAOL,GAC3B,IAAMgD,EAAK3C,EAAMZ,EACXwD,EAAK5C,EAAMZ,EAAIY,EAAMd,EAE3B,OAAIS,EAAQmD,IAEPP,GAAMI,GAAMJ,GAAMK,GAClBN,GAAMK,GAAML,GAAMM,GAClBD,GAAML,GAAMK,GAAMJ,GAAMK,GAAMN,GAAMM,GAAML,GAC1CD,GAAMK,GAAML,GAAMM,GAAML,GAAMI,GAAMJ,GAAMK,MAQnD,OAAOH,EAAS1C,KAAI,SAAAC,GAAK,MAAK,CAC5Bf,EAAGe,EAAMf,EACTG,EAAGY,EAAMZ,EACTC,EAAGW,EAAMX,M,gBC1CQ2D,E,2MAEZxD,MAAgB,CACrBR,OAAQ,GACRiE,eAAgB,I,EAGVC,kBAAmD,G,EAWnD3C,UAAY,SAACvB,EAAuBmE,GACtCA,IAAWrE,EAAmB0B,QAChC,EAAK4C,uBAAuBpE,GAG9B,EAAKc,UAAS,SAACN,GACb,OAAO,eACFA,EADL,CAEER,SACAiE,eAAgBE,IAAWrE,EAAmB0B,OAAS,EAAK6C,wBAAwBrE,GAAUQ,EAAMyD,qB,EA0BlGpB,cAAgB,SAAClC,GACvB,IAAM8B,EAAU,EAAKjC,MAAMR,OAAOsE,MAAK,SAAAtD,GAAK,OAAIA,EAAMf,IAAMU,KAE5D,GAAK8B,EAIL,QAAQ,GACN,KAAKA,EAAQxC,IAAMU,QAA0B,IAAjB8B,EAAQvB,MAAiC,IAAduB,EAAQtC,EAC7D,OAAO,EAAKoE,YAAY5D,GAC1B,KAAK8B,EAAQxC,IAAMU,QAA0B,IAAjB8B,EAAQvB,MAAiC,IAAduB,EAAQtC,EAC7D,OAAO,EAAKqE,YAAY7D,GAC1B,QACE,S,wEAxDJ,OACE,yBAAKc,UAAU,QACb,kBAAC,EAAD,CAAQF,UAAWI,KAAKJ,YACxB,kBAAC,EAAD,CAAMvB,OAAQ2B,KAAKnB,MAAMR,OAAQ6C,cAAelB,KAAKkB,cAAe1B,eAAgBQ,KAAKJ,e,8CAmB/DvB,GAC9B,IAAMiE,EAAwC,GAD8B,uBAG5E,YAAsBjE,EAAtB,+CAA8B,CAAC,IAApByC,EAAmB,aACP,IAAjBA,EAAQvB,MACV+C,EAAeQ,KAAK,CAClBxE,EAAGwC,EAAQxC,EACXyE,eAAgBtB,EAAmBX,EAASzC,GAAQe,KAAI,SAAAC,GAAK,OAAIA,EAAMf,QAPD,kFAY5E,OAAOgE,I,6CAGsBjE,GAA8B,IAAD,uBAC1D,YAAsBA,EAAtB,+CAA8B,CAAC,IAApByC,EAAmB,QAC5Bd,KAAKuC,kBAAkBzB,EAAQxC,GAAKmD,EAAmBX,EAASzC,GAAQe,KAAI,SAAAC,GAAK,OAAIA,EAAMf,MAFnC,qF,kCAuBxCU,GAClBgB,KAAKb,UAAS,SAACN,GACb,IAAMiC,EAAUjC,EAAMR,OAAOsE,MAAK,SAAAtD,GAAK,OAAIA,EAAMf,IAAMU,KAEvD,OAAO,eACFH,EADL,CAEER,OAAQQ,EAAMR,OAAOe,KAAI,SAAAC,GACvB,OAAQA,EAAMf,GACZ,KAAKU,EAEH,OADAgE,QAAQC,IAAI,YAAa5D,EAAMd,GACxB,eACFc,EADL,CAEEd,EAAG,EACHC,EAAG,EACHe,KAAMF,EAAMb,EACZc,KAAMD,EAAMd,EACZ2E,QAAQ,IAEZ,QACE,OAAO7D,MAGbiD,eAAiBxB,EAAD,sBAAsCjC,EAAMyD,gBAA5C,CAA4D,CAC1EhE,EAAGwC,EAAQxC,EACXyE,eAAgBtB,EAAmBX,EAASjC,EAAMR,QAAQe,KAAI,SAAAC,GAAK,OAAIA,EAAMf,QAFpDO,EAAMyD,sB,kCAQnBtD,GAAsB,IAAD,OACjCmE,EAAgBnD,KAAKnB,MAAMyD,eAAeK,MAAK,SAAAtD,GAAK,OAAIA,EAAMf,IAAMU,KAErEmE,GAILnD,KAAKb,UAAS,SAACN,GACb,IAAMY,EAAaZ,EAAMR,OACtBe,KAAI,SAAAC,GACH,OAAQA,EAAMf,GACZ,KAAKU,EACH,OAAO,eACFK,EADL,CAEEd,EAAGc,EAAMC,KACTd,EAAGa,EAAME,KACTD,UAAM,EACNC,UAAM,EACN2D,QAAQ,IAEZ,QACE,OAAO7D,MAIf,OAAO,eACFR,EADL,CAEER,OAAQ,EAAK+E,mBAAmB3D,GAChC6C,eAAgBzD,EAAMyD,eAAeP,QAAO,SAAA1C,GAAK,OAAIA,EAAMf,IAAM6E,EAAc7E,Y,yCAK1DD,GAIzB,IAJgE,IAAD,OACzDgF,EAAOC,OAAOD,KAAKrD,KAAKuC,mBAC1B9C,EAAU,YAAOpB,GAF0C,aAI1D,IAAMsC,EAAG,KACNG,EAAUrB,EAAWkD,MAAK,SAAAtD,GAAK,OAAIA,EAAMf,IAAMqC,KAErD,IAAKG,GAAWA,EAAQoC,OACtB,iBAGFzD,EAAa,EAAK8D,2BAA2BzC,EAASrB,IAPxD,MAAkB4D,EAAlB,eAAwB,IAUxB,OAAO5D,I,iDAG0BqB,EAAiBzC,EAAuBmF,GAIzE,IAJ0G,IAAD,OACrG/D,EAAU,YAAOpB,GACfyD,EAAW9B,KAAKuC,kBAAkBzB,EAAQxC,GAEvCA,EAAI,EAAGmF,EAAKhE,EAAWyC,OAAQ5D,EAAImF,EAAInF,IAAK,CACnD,IAAMe,EAAQI,EAAWnB,GACPwD,EAAS4B,SAASrE,EAAMf,KAQtCe,EAAM6D,QAAS,WACjB,IAAMS,EAAe,EAAKJ,2BAA2BlE,EAAOI,OAAuB,IAAX+D,EAAoBA,EAAS1C,EAAQpC,EAAIoC,EAAQtC,GAEzHiB,EAAaA,EAAWL,KAAI,SAAAwE,GAC1B,IAAMC,EAAgBF,EAAahB,MAAK,SAAAmB,GAAW,OAAIA,EAAYxF,IAAMsF,EAAOtF,KAEhF,OAAKuF,GACID,KAPM,QAcJ,IAAXJ,GAAqBnE,EAAMX,IAAMoC,EAAQpC,EAAIoC,EAAQtC,IACvDiB,EAAWnB,GAAX,eACKe,EADL,CAEEX,EAAGoC,EAAQpC,EAAIoC,EAAQtC,UAIZ,IAAXgF,IACF/D,EAAWnB,GAAX,eACKe,EADL,CAEEX,EAAG8E,MAKT,OAAO/D,M,GAjMsBsB,IAAMC,eCbnB+C,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCVNC,IAASC,OAAO,kBAAC,EAAD,MAAeC,SAASC,eAAe,SDmIjD,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.eaac6be2.chunk.js","sourcesContent":["\n\n\nexport enum LayoutUpdateSource {\n  Editor = 0,\n  View = 1,\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  setLayout(layout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\nexport interface IState {\n  layout: Array<Layout>;\n}\n\n\nconst INITIAL_STATE: IState = {\n  layout: [\n    { i: '0', w: 2, h: 50, x: 0, y: 0, minH: 0 },\n    { i: '1', w: 2, h: 50, x: 2, y: 0, minH: 0 },\n    { i: '2', w: 4, h: 50, x: 0, y: 50, minH: 0 },\n    { i: '3', w: 2, h: 50, x: 0, y: 100, minH: 0 },\n    { i: '4', w: 2, h: 50, x: 2, y: 100, minH: 0 },\n    { i: '5', w: 2, h: 50, x: 0, y: 150, minH: 0 },\n    { i: '6', w: 2, h: 50, x: 2, y: 150, minH: 0 },\n    { i: '7', w: 2, h: 50, x: 0, y: 200, minH: 0 },\n    { i: '8', w: 2, h: 50, x: 2, y: 200, minH: 0 },\n    { i: '9', w: 2, h: 50, x: 0, y: 250, minH: 0 },\n    { i: '10', w: 2, h: 50, x: 2, y: 250, minH: 0 },\n    { i: '11', w: 2, h: 50, x: 0, y: 300, minH: 0 },\n    { i: '12', w: 2, h: 50, x: 2, y: 300, minH: 0 },\n    { i: '13', w: 2, h: 50, x: 0, y: 350, minH: 0 },\n    { i: '14', w: 2, h: 50, x: 2, y: 350, minH: 0 },\n    { i: '15', w: 2, h: 50, x: 0, y: 400, minH: 0 },\n    { i: '16', w: 2, h: 50, x: 2, y: 400, minH: 0 },\n    { i: '17', w: 2, h: 50, x: 0, y: 450, minH: 0 },\n    { i: '18', w: 2, h: 50, x: 2, y: 450, minH: 0 },\n    { i: '19', w: 2, h: 50, x: 0, y: 500, minH: 0 },\n    { i: '20', w: 2, h: 50, x: 2, y: 500, minH: 0 },\n  ],\n};\n\n\nexport default class EditorView extends React.PureComponent<IProps, IState> {\n\n  public state: IState = { ...INITIAL_STATE };\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"editor\">\n        <h1>Editor</h1>\n\n        <div className=\"main-action\">\n          <button className=\"save\" onClick={this.commitLayout}>Save Layout</button>\n        </div>\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={true}\n          isResizable={true}\n          compactType=\"vertical\"\n          layout={this.state.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.onLayoutChange}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <button key={entry.i} data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.state.layout.map(entry => (\n      <div key={entry.i} className={`item ${this.isHidden(entry) ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private isHidden(element: Layout): boolean {\n    return element.maxH !== void 0;\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n\n    return this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                maxW: entry.maxW !== void 0 ? void 0 : entry.w,\n                maxH: entry.maxH !== void 0 ? void 0 : entry.h,\n              };\n            default:\n              return entry;\n          }\n        })\n      };\n    });\n  }\n\n  private onLayoutChange = (nextLayout: Array<Layout>): void => {\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout: nextLayout,\n      };\n    });\n  }\n\n  private commitLayout = (): void => {\n    this.props.setLayout(this.state.layout.map(entry => {\n      switch (true) {\n        case entry.maxH !== void 0:\n          return {\n            ...entry,\n            h: 0,\n          };\n        default:\n          return entry;\n      }\n    }), LayoutUpdateSource.Editor);\n  }\n}\n","\nimport React from 'react';\nimport Container, { Layout } from 'react-grid-layout';\n\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IProps {\n  layout: Array<Layout>;\n  toggleElement(index: string): void;\n  onLayoutChange(nextLayout: Array<Layout>, source: LayoutUpdateSource): void;\n}\n\n\n\nexport default class View extends React.PureComponent<IProps, {}> {\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"view\">\n        <h1>View</h1>\n\n        {this.mapButtons()}\n\n        <Container\n          width={600}\n          margin={[0, 0]}\n          draggableCancel=\".non-draggable\"\n          isDraggable={false}\n          isResizable={false}\n          verticalCompact={true}\n          compactType=\"vertical\"\n          layout={this.props.layout}\n          cols={4}\n          rowHeight={1}\n          onLayoutChange={this.changeInterceptor}\n        >\n          {this.mapItems()}\n        </Container>\n      </div>\n    );\n  }\n\n  private mapButtons(): Array<React.ReactNode> {\n    return this.props.layout.sort((a, b) => Number(a.i) > Number(b.i) ? 1 : -1).map(entry => (\n      <button key={entry.i} data-index={entry.i} onClick={this.toggleSingleElement}>Toggle {entry.i}</button>\n    ))\n  }\n\n  private mapItems(): Array<React.ReactNode> {\n    return this.props.layout.map(entry => (\n      <div key={entry.i} className={`item ${this.isHidden(entry) ? 'hidden' : ''}`}>\n        {entry.i}\n      </div>\n    ));\n  }\n\n  private isHidden(element: Layout): boolean {\n    return element.maxH !== void 0 && element.h === 0;\n  }\n\n  private toggleSingleElement = (evt: React.MouseEvent<HTMLButtonElement>): void => {\n    const index = evt.currentTarget.dataset.index;\n\n    if (!index) {\n      return;\n    }\n    \n    this.props.toggleElement(index);\n  }\n\n  private changeInterceptor = (nextLayout: Array<Layout>): void => {\n    this.props.onLayoutChange(nextLayout, LayoutUpdateSource.View);\n  }\n}\n","\nimport { Layout } from 'react-grid-layout';\nimport { IHiddenElement, IBottomSiblings } from './App';\n\n\n\n\n\nexport function findUpperSibling(element: Layout, elements: Array<Layout>): Layout | undefined {\n  return elements\n    .sort((a, b) => a >= b ? -1 : 1)\n    .find((entry) => entry.y + entry.h === element.y);\n}\n\n\nexport function findBottomSiblings(element: Layout, elements: Array<Layout>): Array<IBottomSiblings> {\n  const x2 = element.x;\n  const x3 = element.x + element.w;\n  // ? -1 : 1\n  const sorted = elements.sort((a, b) => {\n    switch (true) {\n      case a > b:\n        return -1;\n      case a < b:\n        return 1;\n      default:\n        return 0;\n    }\n  });\n  const siblings = sorted.filter(entry => {\n    const x0 = entry.x;\n    const x1 = entry.x + entry.w;\n    const h = element.h === 0 && element.maxH !== void 0 ? element.maxH : element.h;\n    return element.i !== entry.i && element.y + h === entry.y && (\n      (x3 >= x0 && x3 <= x1) ||\n      (x2 >= x0 && x2 <= x1) ||\n      (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n      (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n    );\n  });\n\n  // If no bottom siblings, it should instead look for closest bottom sibling that interacts along X axis\n  if (!siblings.length) {\n    const selfIndex = sorted.findIndex(entry => entry.i === element.i);\n\n    // Find all the other ones that are potentially bellow it\n    // Filter them out with only the first ones that it might come into contact with remaining in the list\n    return sorted.filter((entry, index) => {\n      const x0 = entry.x;\n      const x1 = entry.x + entry.w;\n\n      if (index > selfIndex) {\n        return (\n          (x3 >= x0 && x3 <= x1) ||\n          (x2 >= x0 && x2 <= x1) ||\n          (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n          (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n        );\n      }\n\n      return false;\n    });\n  }\n\n  return siblings.map(entry => ({\n    i: entry.i,\n    x: entry.x,\n    y: entry.y,\n  }))\n\n\n  // return elements\n  //   .filter(entry => {\n  //     const x0 = entry.x;\n  //     const x1 = entry.x + entry.w;\n  //     const h = element.h === 0 && element.maxH !== void 0 ? element.maxH : element.h;\n  //     return element.i !== entry.i && element.y + h === entry.y && (\n  //       (x3 >= x0 && x3 <= x1) ||\n  //       (x2 >= x0 && x2 <= x1) ||\n  //       (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n  //       (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n  //     );\n  //   })\n  //   .map(entry => ({\n  //     i: entry.i,\n  //     x: entry.x,\n  //     y: entry.y,\n  //   }));\n}\n\n\nexport function elementExists(index: string, elements: Array<Layout>): boolean {\n  return elements.findIndex(entry => entry.i === index) !== -1;\n}\n\n\nexport function hiddenElementExists(index: string, hiddenElements: Array<IHiddenElement>): boolean {\n  return hiddenElements.findIndex(entry => entry.element.i === index) !== -1;\n}\n\n\nexport function findXAxisCollisions(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const x2 = element.x;\n  const x3 = element.x + element.w;\n\n  return elements.filter(entry => {\n    const x0 = entry.x;\n    const x1 = entry.x + entry.w;\n\n    return (\n      (\n        (element.y >= entry.y && element.y + element.h >= entry.y) ||\n        (element.y <= entry.y + entry.h && element.y <= entry.y )\n      ) &&\n      (\n        (x3 >= x0 && x3 <= x1) ||\n        (x2 >= x0 && x2 <= x1) ||\n        (x0 >= x2 && x0 <= x3 && x1 >= x2 && x1 <= x3) ||\n        (x2 >= x0 && x2 <= x1 && x3 >= x0 && x3 <= x1)\n      )\n    );\n  });\n}\n\n\n// export function findCollisions(element: string, elements: Array<Layout>): Array<Layout> {\n//   return elements\n//     .sort((a, b) => a >= b ? -1 : 1)\n//     .filter(entry => (\n\n//     ));\n// }\n\n\nexport function findNearestSiblingToAppendAfter(siblingIndex: string, elements: Array<Layout>, hiddenElements: Array<IHiddenElement>): Layout | undefined {\n  if (hiddenElementExists(siblingIndex, hiddenElements)) {\n    const hiddenElement = hiddenElements.find(element => element.element.i === siblingIndex);\n    // If no element was found, it should check whether the position where the old hidden element used to be had\n    // any siblings on the X axis and check whether this element could potentially collide with those elements.\n    // If there are any collisions, find the first collision that has the heighest Y + H along the Y axis and return it as the append index\n\n    if (hiddenElement && !hiddenElement.upperSibling) {\n      // Should sort by by highest y + h in a descending manner\n      // TODO: Check whether the X axis sibling actually collides, just filter those that do not collide out\n      const xAxisSiblings = findXAxisCollisions(hiddenElement.element, elements)\n        .sort((a, b) => {\n          return a.y + a.h >= b.y + b.h ? -1 : 1;\n        });\n\n      if (xAxisSiblings.length === 0) {\n        return void 0;\n      }\n      \n      return xAxisSiblings[xAxisSiblings.length - 1];\n    }\n\n    if (!hiddenElement) {\n      return void 0;\n    }\n\n    return findNearestSiblingToAppendAfter(hiddenElement.upperSibling as string, elements, hiddenElements);\n  }\n\n  const element = elements.find(entry => entry.i === siblingIndex);\n\n  if (!element) {\n    return void 0;\n  }\n\n  return element;\n}\n\nexport function pushDownElements(element: Layout, elements: Array<Layout>): Array<Layout> {\n  const collisions = findXAxisCollisions(element, elements);\n  \n  if (collisions.length === 0) {\n    return elements;\n  }\n\n  const nextLayout = elements.map(entry => {\n    if (entry.i === element.i) {\n      return entry;\n    }\n\n    const colliding = collisions.find(potentialCollision => potentialCollision.i === entry.i);\n\n    switch (true) {\n      case colliding !== void 0 && colliding.i === entry.i:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n\n  return nextLayout;\n  // return pushDownElements(collisions[])\n}\n\n\nexport function addElementAtPosition(pos: number, element: Layout, elements: Array<Layout>): Array<Layout> {\n  const nextLayout = [{\n    ...element,\n    y: pos,\n  }, ...elements];\n\n  return pushDownElements(element, nextLayout);\n}\n\n\nexport function adjustBottomSiblings(element: Layout, siblings: Array<IBottomSiblings>, elements: Array<Layout>): Array<Layout> {\n  return elements.map(entry => {\n    if (element.i === entry.i) {\n      return entry;\n    }\n\n    const isSibling = siblings.find(sibling => sibling.i === entry.i) !== void 0;\n\n    switch (isSibling) {\n      case true:\n        return {\n          ...entry,\n          y: element.y + element.h,\n        };\n      default:\n        return entry;\n    }\n  });\n}","\nimport React from 'react';\nimport { Layout } from 'react-grid-layout';\n\nimport Editor from './EditorView';\nimport View from './FinalView';\nimport { findBottomSiblings } from '../utils';\n\nimport './Style.css';\nimport 'react-grid-layout/css/styles.css';\nimport { LayoutUpdateSource } from './Enums';\n\n\nexport interface IHiddenElement {\n  i: string;\n  bottomSiblings: Array<string>;\n}\n\n\ninterface IState {\n  layout: Array<Layout>;\n  hiddenElements: Array<IHiddenElement>;\n}\n\n\nexport default class App extends React.PureComponent<{}, IState> {\n\n  public state: IState = {\n    layout: [],\n    hiddenElements: [],\n  }\n\n  private layoutYSiblingMap: Record<string, Array<string>> = {};\n\n  public render(): React.ReactNode {\n    return (\n      <div className=\"base\">\n        <Editor setLayout={this.setLayout} />\n        <View layout={this.state.layout} toggleElement={this.toggleElement} onLayoutChange={this.setLayout} />\n      </div>\n    );\n  }\n\n  private setLayout = (layout: Array<Layout>, source: LayoutUpdateSource): void => {\n    if (source === LayoutUpdateSource.Editor) {\n      this.buildLayoutYSiblingMap(layout);\n    }\n\n    this.setState((state: IState) => {\n      return {\n        ...state,\n        layout,\n        hiddenElements: source === LayoutUpdateSource.Editor ? this.buildHiddenElementState(layout) : state.hiddenElements,\n      };\n    });\n  }\n\n  private buildHiddenElementState(layout: Array<Layout>): Array<IHiddenElement> {\n    const hiddenElements: Array<IHiddenElement> = [];\n\n    for (const element of layout) {\n      if (element.maxH !== void 0) {\n        hiddenElements.push({\n          i: element.i,\n          bottomSiblings: findBottomSiblings(element, layout).map(entry => entry.i),\n        });\n      }\n    }\n\n    return hiddenElements\n  }\n\n  private buildLayoutYSiblingMap(layout: Array<Layout>): void {\n    for (const element of layout) {\n      this.layoutYSiblingMap[element.i] = findBottomSiblings(element, layout).map(entry => entry.i);\n    }\n  }\n\n  private toggleElement = (index: string): void => {\n    const element = this.state.layout.find(entry => entry.i === index);\n\n    if (!element) {\n      return;\n    }\n\n    switch (true) {\n      case element.i === index && element.maxH === void 0 && element.h !== 0:\n        return this.hideElement(index);\n      case element.i === index && element.maxH !== void 0 && element.h === 0:\n        return this.showElement(index);\n      default:\n        return;\n    }\n  }\n\n  private hideElement(index: string): void {\n    this.setState((state: IState) => {\n      const element = state.layout.find(entry => entry.i === index);\n\n      return {\n        ...state,\n        layout: state.layout.map(entry => {\n          switch (entry.i) {\n            case index:\n              console.log('Ya, cool:', entry.w);\n              return {\n                ...entry,\n                w: 0,\n                h: 0,\n                maxH: entry.h,\n                maxW: entry.w,\n                static: true,\n              };\n            default:\n              return entry;\n          }\n        }),\n        hiddenElements: !element ? state.hiddenElements : [...state.hiddenElements, {\n          i: element.i,\n          bottomSiblings: findBottomSiblings(element, state.layout).map(entry => entry.i),\n        }],\n      };\n    });\n  }\n\n  private showElement(index: string): void {\n    const hiddenElement = this.state.hiddenElements.find(entry => entry.i === index);\n\n    if (!hiddenElement) {\n      return;\n    }\n\n    this.setState((state: IState) => {\n      const nextLayout = state.layout\n        .map(entry => {\n          switch (entry.i) {\n            case index:\n              return {\n                ...entry,\n                w: entry.maxW as number,\n                h: entry.maxH as number,\n                maxW: void 0,\n                maxH: void 0,\n                static: false,\n              };\n            default:\n              return entry;\n          }\n        });\n\n      return {\n        ...state,\n        layout: this.normalizePositions(nextLayout),\n        hiddenElements: state.hiddenElements.filter(entry => entry.i !== hiddenElement.i),\n      };\n    });\n  }\n\n  private normalizePositions(layout: Array<Layout>): Array<Layout> {\n    const keys = Object.keys(this.layoutYSiblingMap);\n    let nextLayout = [...layout];\n\n    for (const key of keys) {\n      const element = nextLayout.find(entry => entry.i === key);\n\n      if (!element || element.static) {\n        continue;\n      }\n\n      nextLayout = this.mapElementSiblingPositions(element, nextLayout);\n    }\n\n    return nextLayout;\n  }\n\n  private mapElementSiblingPositions(element: Layout, layout: Array<Layout>, forceY?: number): Array<Layout> {\n    let nextLayout = [...layout];\n    const siblings = this.layoutYSiblingMap[element.i];\n\n    for (let i = 0, ii = nextLayout.length; i < ii; i++) {\n      const entry = nextLayout[i];\n      const isSibling = siblings.includes(entry.i);\n\n      if (!isSibling) {\n        continue;\n      }\n\n      // If the element is hidden we adjust its siblings instead to account for new positions related to itself.\n      // That's because all the siblings bellow the hidden sibling should adhere to the current element's position.\n      if (entry.static) {\n        const mappedLayout = this.mapElementSiblingPositions(entry, nextLayout, forceY !== void 0 ? forceY : element.y + element.h);\n\n        nextLayout = nextLayout.map(nEntry => {\n          const mappedElement = mappedLayout.find(mappedEntry => mappedEntry.i === nEntry.i);\n\n          if (!mappedElement) {\n            return nEntry;\n          }\n\n          return mappedElement;\n        });\n      }\n\n      if (forceY === void 0 && entry.y !== element.y + element.h) {\n        nextLayout[i] = {\n          ...entry,\n          y: element.y + element.h,\n        };\n      }\n\n      if (forceY !== void 0) {\n        nextLayout[i] = {\n          ...entry,\n          y: forceY,\n        };\n      }\n    }\n\n    return nextLayout;\n  }\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport NoHideApp from './NoHide';\nimport * as serviceWorker from './serviceWorker';\n\n// ReactDOM.render(<App />, document.getElementById('root'));\nReactDOM.render(<NoHideApp />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}